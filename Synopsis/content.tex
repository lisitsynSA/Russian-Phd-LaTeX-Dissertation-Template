\pdfbookmark{Общая характеристика работы}{characteristic}             % Закладка pdf
\section*{Общая характеристика работы}


    \nocite{vakbib1}%
    \nocite{vakbib2}%
    \nocite{confbib1}%conf
    \nocite{confbib2}%conf
    \nocite{confbib3}%conf

\newcommand{\actuality}{\pdfbookmark[1]{Актуальность}{actuality}\underline{\textbf{\actualityTXT}}}
\newcommand{\progress}{\pdfbookmark[1]{Разработанность темы}{progress}\underline{\textbf{\progressTXT}}}
\newcommand{\aim}{\pdfbookmark[1]{Цели}{aim}\underline{{\textbf\aimTXT}}}
\newcommand{\tasks}{\pdfbookmark[1]{Задачи}{tasks}\underline{\textbf{\tasksTXT}}}
\newcommand{\aimtasks}{\pdfbookmark[1]{Цели и задачи}{aimtasks}\aimtasksTXT}
\newcommand{\novelty}{\pdfbookmark[1]{Научная новизна}{novelty}\underline{\textbf{\noveltyTXT}}}
\newcommand{\influence}{\pdfbookmark[1]{Практическая значимость}{influence}\underline{\textbf{\influenceTXT}}}
\newcommand{\methods}{\pdfbookmark[1]{Методология и методы исследования}{methods}\underline{\textbf{\methodsTXT}}}
\newcommand{\defpositions}{\pdfbookmark[1]{Положения, выносимые на защиту}{defpositions}\underline{\textbf{\defpositionsTXT}}}
\newcommand{\reliability}{\pdfbookmark[1]{Достоверность}{reliability}\underline{\textbf{\reliabilityTXT}}}
\newcommand{\probation}{\pdfbookmark[1]{Апробация}{probation}\underline{\textbf{\probationTXT}}}
\newcommand{\contribution}{\pdfbookmark[1]{Личный вклад}{contribution}\underline{\textbf{\contributionTXT}}}
\newcommand{\publications}{\pdfbookmark[1]{Публикации}{publications}\underline{\textbf{\publicationsTXT}}}

\input{common/characteristic} % Характеристика работы по структуре во введении и в автореферате не отличается (ГОСТ Р 7.0.11, пункты 5.3.1 и 9.2.1), потому её загружаем из одного и того же внешнего файла, предварительно задав форму выделения некоторым параметрам

%Диссертационная работа была выполнена при поддержке грантов \dots

%\underline{\textbf{Объем и структура работы.}} Диссертация состоит из~введения,
%четырех глав, заключения и~приложения. Полный объем диссертации
%\textbf{ХХХ}~страниц текста с~\textbf{ХХ}~рисунками и~5~таблицами. Список
%литературы содержит \textbf{ХХX}~наименование.

\pdfbookmark{Содержание работы}{description}                          % Закладка pdf
\section*{Содержание работы}
\underline{\textbf{Введение}} содержит обоснование актуальности
исследований, проводимых в~рамках данной диссертационной работы,
обзор научной литературы по~изучаемой проблеме, а также формулируется цель, ставятся задачи, излагается научная новизна
и практическая значимость представляемой работы. 

\begin{figure}[!h]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{1}
    }
    \caption{Алгоритм работы бинарного оптимизатора BOLT}\label{fig:BOLT}
\end{figure}

\underline{\textbf{Первая глава}} посвящена обзору существующих технологий бинарных трансляторов, используемых для генерации оптимизированных исполняемых файлов приложений. В начале главы приводится принятая классификация современных бинарных трансляторов. Затем рассматриваются общие принципы работы существующих технологий бинарной оптимизации. Далее описывается схема работы бинарных оптимизаторов, использующих  профильную информацию исполнения приложения.

Приводится описание работы бинарного оптимизатора BOLT (Binary Optmization and Layout Tool) (рисунки \cref{fig:BOLT} и \cref{fig:BinOpt}). Обсуждаются вопросы получения профильной информации для его работы на x86 архитектуре с использованием аппаратной поддержки профилирования -- LBR (Last Branch Record)  (рисунок \cref{fig:BinOptX86}). Также рассматривается альтернативный вариант сбора профильной информации без аппаратной поддержки сбора статистики  переходов -- режим работы no\_LBR\_mode. В нём собирается только статистика исполняемых адресов в бинарном файле.

\begin{figure}[!h]
    \centerfloat{
        \includegraphics[width=0.5\linewidth]{2}
    }
    \caption{Схема оптимизации бинарного файла на x86 архитектуре}\label{fig:BinOptX86}
\end{figure}

Кроме того, подробно рассматриваются вопросы формата профилей с информацией о взятых переходах и без неё. Разбирается пример оптимизации простого приложения с условным переходом в цикле. Приводится его граф потока управления и варианты раскладки  его бинарного кода в памяти.

\begin{figure}[!h]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{3}
    }
    \caption{Последовательность работы бинарного оптимизатора BOLT}\label{fig:BinOpt}
\end{figure}

В конце первой главы рассматривается вопрос поддержки архитектуры ARM в бинарном оптимизаторе BOLT, варианты получения профильной информации на ней и возможности оптимизаций, приведены примеры профилей в формате BOLT.

\underline{\textbf{Вторая глава}} посвящена разработанному универсальному методу получения профильной информации приложения из трасс исполнения.

В \underline{\textbf{разделе 2.1}} описывается метод получения трасс исполнения приложений на основе динамической бинарной инструментации (DBI, Dynamic Binary Instrumentation) и предлагается схема оптимизации бинарного файла на ARM архитектуре (рисунок \cref{fig:SugOpt}).

\begin{figure}[!h]
    \centerfloat{
        \includegraphics[width=0.6\linewidth]{9}
    }
    \caption{Предлагаемая схема оптимизации бинарного файла на ARM архитектуре}\label{fig:SugOpt}
\end{figure}

С помощью DBI фреймворка производится запись трассы исполнения приложения. Записывается последовательность инструкций, поступающих на процессор. После исполнения последовательность анализируется конвертером для генерации профиля исполнения, который записывается в формате BOLT. Такое решение приводит к замедлению работы оптимизируемого приложения в несколько раз, но создаёт трассу, которую можно анализировать без привязки к конкретной микроархитектуре.

В \underline{\textbf{разделе 2.2}} изложен алгоритм работы модели предсказателя переходов по трассе исполнения приложения, необходимый для получения информации о промахах предсказателя для профиля (рисунок \cref{fig:ProfTrace}).

\begin{figure}[!h]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{10}
    }
    \caption{Схема генерации профиля из трассы исполнения}\label{fig:ProfTrace}
\end{figure}

Для получения информации о переходах для профиля конвертер проходит по всей трассе и находит инструкции, меняющие поток управления: B, BR, BL, BLR, B.cond, TBZ, TBNZ, CBZ, CBNZ, RET. После этого информация поступает в модель предсказателя переходов (Branch Predictor Model). Данная модель выбирается в зависимости от конкретной микроархитектуры процессора, для которого оптимизируется приложение. В итоге собирается информация для получения количества не предсказанных и количества взятых переходов.

В \underline{\textbf{разделе 2.3}} приводится сравнение предлагаемого решения с уже существующим подходом работы бинарного оптимизатора BOLT. Сопоставляются профили, полученные на ARM и x86 архитектурах. Метод сбора профильной информации с использованием трассы исполнения был проверен на приложениях, собранных под архитектуру ARM. Для аналогичных программ под x86 собранные с помощью LBR профили коррелируют с полученными, что позволяет использовать динамическую бинарную инструментацию с последующим анализом переходов для использования с оптимизатором BOLT.

Помимо этого, сравниваются подходы получения профильной информации с помощью аппаратной поддержки LBR и получение из трасс исполнения приложения. Во-первых, трасса исполнения зависит только от архитектуры, но не микроахитетктуры устройства, на котором происходит динамическая бинарная инструментация, что означает возможность повторной оптимизации приложения под другую микроахитектуру с другой моделью предсказателя переходов. Во-вторых, собранный профиль покрывает всё исполнение оптимизируемого приложения, а не часть исполнения как в случае с LBR. Таким образом, полученная информация более корректна, так как избавляет профиль от искажений, связанных с ожиданием готовности периферии процессора, например, обращение в память.

В \underline{\textbf{разделе 2.4}} описываются используемые синтетические тесты для проверки корректности работы предлагаемого метода получения профильной информации.

Искусственно были созданы примеры, когда исполняемый код перемешан с не исполняемым холодным кодом, что приводит к неэффективному использованию инструкционного кэша. Для генерации бинарного файла большого размера (> 10 МБ) применялись рекурсивный вызов шаблонных функций в языке программирования C++. С их помощью компилятор создавал множественные копии функций с разными шаблонными константами, тем самым увеличивая размер кода до нужного значения. Исполняемый код равномерно распределяется по секции, чередуясь с холодными функциями. 

В \underline{\textbf{разделе 2.5}} приводятся результаты запусков, оптимизированных на основе профильной информации, которая была собрана из трасс исполнения синтетических тестов.

\begin{figure}[H]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{13}
    }
    \caption{Сравнение результатов запусков оригинального (снизу) и оптимизированного (сверху) бинарных файлов синтетического теста}\label{fig:SynthRes}
\end{figure}

Полученные статистические данные  (рисунок \cref{fig:SynthRes}) показывают понижение практически до нуля количество промахов по iTLB, увеличение IPC (instruction per clock) на 41\% и уменьшение времени работы на 29\%. Для тестирования была выбрана микроархитектура ARM Cortex A76.

\underline{\textbf{Третья глава}} посвящена описанию улучшений в бинарном оптимизаторе BOLT под ARM архитектуру, их верификации и тестированию.

В \underline{\textbf{разделе 3.1}} рассматривается проблема длинных переходов в бинарной оптимизации. Описывается метод оптимизации трамплинов, позволяющий уменьшить количество добавляемых для трамплина инструкций и не использовать дополнительный регистр.

Перекомпоновка кода проще реализуется на CISC архитектуре за счёт возможности добавления длинных прыжков одной инструкцией. На RISC архитектурах количество битов смещения в инструкциях переходов меньше, что приводит к ограничению диапазона возможного перемещения. Также инструкция загрузки в регистр адреса, зависящего от счетчика инструкций, на ARM архитектуре ограничена 20 битами, выделенными на смещение, и накладывает возможный диапазон перемещения ± 1 мегабайт. Все инструкции, которые зависят от своего адреса (переходы, загрузка адреса, загрузка по регистру/смещению), после оптимизации необходимо проверить на возможность записи нового смещения в отведенные для этого биты.

\begin{figure}[H]
    \centerfloat{
        \includegraphics[width=0.8\linewidth]{11}
    }
    \caption{Пример перекомпоновки кода}\label{fig:HotMove}
\end{figure}

Таким образом, при перемещении горячего кода, ссылающегося на холодный участок (черная стрелка на рисунке \cref{fig:HotMove}), происходит переполнение значения смещения, и оптимизация становится некорректной.

Для решения данной проблемы необходимо добавить трамплин – дополнительный код, позволяющий генерировать произвольный адрес и произвести переход либо загрузку по данному значению. Подобное решение будет увеличивать размер кода, что приведёт к понижению производительности, но диапазон перемещаемого кода будет увеличен.

\begin{figure}[!h]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{opt4}
    }
    \caption{Сравнение трамплинов}\label{fig:CompTramp}
\end{figure}

Для условных переходов можно написать маленькие трамплины размером в одну инструкцию с помощью добавления одного безусловного перехода в случае, если смещение занимает больше 19, но меньше 26 бит (рисунок \cref{fig:CompTramp}).
 
\begin{figure}[H]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{opt2}
    }
    \caption{Схема добавления трамплинов для ADR (сверху) и Bcc (снизу) инструкций}\label{fig:Tramp}
\end{figure}

В данном варианте необходимо инвертировать условие инструкции и метку для прыжка поставить через одну инструкцию прямого перехода, вставленную оптимизатором непосредственно после условного перехода. Получаем увеличение возможного региона перемещения в 128 раз за счёт отличий в кодировках Bcc и B, а увеличение кода произошло всего на 1 инструкцию (рисунок \cref{fig:Tramp}).

В \underline{\textbf{разделе 3.2}} описывается проблема бинарной оптимизации исполняемых файлов под ARM архитектуру, в которых используются таблицы переходов.

\begin{figure}[!h]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{jt4}
    }
    \caption{Оптимизированный вариант ассемблерного кода для switch-case случая}\label{fig:Switch}
\end{figure}

При перемещении кода конкретного варианта конструкции switch-case, необходимо модифицировать запись в таблице, используемую в косвенном переходе. Оптимизатор узнает адрес записи из релокационной информации, которая для некоторых случаев кода ARM архитектуры не будет корректной (рисунок \cref{fig:Switch}). Это происходит по причине несоответствия адреса, от которого вычисляется целевой адрес для прыжка при исполнении и генерации релокационной информации.

Данная проблема решается переиспользованием оригинального участка кода с данным косвенным переходом. В этом случае необходимо сохранить копию оригинальной секции .bolt.org.text.

В \underline{\textbf{разделе 3.3}} предлагается метод верификации оптимизированного бинарного файла.

Для решения данной задачи был разработан специальный формат, описывающий преобразования исполняемого файла в оптимизированный, так называемый remap-файл. В нём записывается информация о всех совершенных перестановках кода и дополнительная информация, обозначающая инструкции, подвергнутые преобразованиям в процессе перекомпоновки (PC-relative инструкции).

\begin{figure}[!h]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{v2}
    }
    \caption{Схема верификации бинарного файла}\label{fig:Verif}
\end{figure}

В рамках данной работы в оптимизатор BOLT был добавлен проход, генерирующий remap-файл, а также написан статический анализатор, сравнивающий оригинальный и оптимизированный исполняемые файлы по данному remap-файлу (рисунок \cref{fig:Verif}). Реализованы следующие проверки:

\begin{enumerate}[beginpenalty=10000]
  \item Проверка корректности оптимизированных линейных участков кода.
  \item Проверка корректности создания теневых точек.
  \item Сравнение инструкций оптимизированных и исходный линейных участков.
\end{enumerate}	

В \underline{\textbf{разделе 3.4}} описываются результаты тестирования синтетических тестов и общих наборов тестов после оптимизации модифицированным бинарным транслятором BOLT (рисунки \cref{fig:OrigClang} и \cref{fig:OptClang}).

Для проверки оптимизации на реальном приложении был выбран набор тестов производительности GeekBench. Среди всего набора был выбран тест с наибольшим числом iTLB и L1I промахов – Clang. При компиляции набора тестов были использован флаг <<-O2>>, который соответствует оптимизациям при стандартной сборке приложений.

По результатам тестов был получен прирост в показателях теста на 10\%, уменьшение iTLB и L1I промахов на 32\% и 38\% соответственно, что является показателем увеличения средней температуры кода. При этом остальные тесты из набора GeekBench либо не улучшили производительность, либо ухудшили её.

\begin{figure}[H]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{14}
    }
    \caption{Результаты исполнения оригинального Clang теста}\label{fig:OrigClang}
\end{figure}

\begin{figure}[H]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{15}
    }
    \caption{Результаты исполнения оптимизированного Clang теста}\label{fig:OptClang}
\end{figure}

В \underline{\textbf{четвертой главе}} приведено описание бинарных оптимизаций на основе трасс исполнения приложения.

В \underline{\textbf{разделе 4.1}} описываются проблемы оптимизаций с профильной информацией.

Для работы оптимизатора BOLT необходимы значения счетчика команд и последние взятые переходы с информацией от предсказателя переходов. Во время сбора характеристик программа исполняется по определенному сценарию: определенные входные данные, параметры окружения, контекст и т.д. Полученная профильная информация будет показывать характеристики этого выбранного сценария.

После оптимизации приложения с данным профилем запуск по данному сценарию будет показывать прирост производительности, но при проверке производительности с другими входными параметрами на данном приложении такого же прироста производительности получить не удастся (вероятно будет происходить регрессия).

Кроме того, приводится пример приложения, при оптимизации которого будет получен либо прирост, либо регрессия производительности в зависимости от выбранного сценария.

В \underline{\textbf{разделе 4.2}} рассматривается дополнительная информация, которую можно извлечь из трассы исполнения и применить для последующей бинарной оптимизации приложения.

Трасса исполнения содержит в себе гораздо больше информации, чем профиль, который в конечном итоге используется для оптимизации приложения. Помимо количества сделанных переходов на каждой инструкции и изменения программного счетчика, есть информация о последовательности сделанных переходов, которую можно учитывать во время оптимизации.

Также для оптимизации можно добавить в трассу информацию про использованные адреса в инструкциях загрузки и выгрузки. Таким образом, можно достать подробную информацию для оптимизации данных в бинарном файле.

В \underline{\textbf{разделе 4.3}} приводится описание мультипрофильного анализа трасс исполнения приложения. Вводятся основные необходимые термины для данного анализа: интервалы инструкций, фазы исполнения и мультипрофиль.

Трасса разбивается на одинаковые интервалы по количеству инструкций. Это необходимо для анализа исполнения в рамках одного отрезка времени – интервала инструкций, так как требуется найти похожие интервалы и объединить их в фазы.

Для большей наглядности граф исполнения отображается в виде тепловой карты (рисунок \cref{fig:HeatMap}). По оси X – интервалы инструкций согласно времени исполнения, по оси Y – номер линейного участка кода.

\begin{figure}[!h]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{_9}
    }
    \caption{Построение тепловой карты линейных участков}\label{fig:HeatMap}
\end{figure}

На каждом интервале исполнялся определенный набор линейных участков кода, который будет характеризовать интервал инструкций. Если составить n-мерное пространство, где n – количество линейных участков кода, а координаты – количество исполненных соответствующих линейных участков на выбранном интервале, то каждому интервалу в данном пространстве будет соответствовать точка.

Также в разделе приводится алгоритм кластеризации интервалов. Каждый полученный кластер интервалов инструкций означает определенную фазу. Кластеризация проводится с помощью итеративного алгоритма объединения фаз. По переключениям между фазами строится граф исполнения. Он является аналогом графа потока управления, но на более высоком уровне, показывая переключения не между линейными участками, а между макросостояниями исполнения программы.

\begin{figure}[H]
    \begin{minipage}[b][][b]{1.0\linewidth}\centering
        \includegraphics[width=0.8\linewidth]{mi1} \\ а)до оптимизации
    \end{minipage}
    \vfill
    \begin{minipage}[b][][b]{1.0\linewidth}\centering
        \includegraphics[width=0.8\linewidth]{mi2} \\ б)после оптимизации
    \end{minipage}
    \caption{Дублирование кода на основе мультипрофиля}
    \label{fig:MultiProfileOpt}
\end{figure}

Для завершения анализа приложения необходимо построить соответствие между фазами и линейными участками приложения. Для этого каждый линейный участок анализируется отдельно, выбирая интервал с его наибольшим количеством исполнений. Линейному участку кода будет соответствовать фаза, которая включает в себя этот интервал.

В \underline{\textbf{разделе 4.4}} описывается бинарная оптимизация - дублирование кода на основе мультипрофиля.

Выстраивая соответствие между линейными участками кода и фазами, выбиралась фаза, к которой принадлежит интервал инструкций с наибольшим количеством исполнений данного линейного участка. Однако, может произойти ситуация, когда линейный участок исполнялся на интервалах инструкций, относящихся к разным фазам. В этом случае необходимо запоминать такие линейные участки для последующего анализа необходимости дублирования данного кода.

Используя эвристически подобранные соотношения, выбираются те линейные участки, которые относятся одновременно к нескольким фазам. После этого данные участки помечаются для дублирования бинарным оптимизатором BOLT (рисунок \cref{fig:MultiProfileOpt}).

В \underline{\textbf{разделе 4.5}} приводятся результаты запусков тестов, оптимизированных с помощью дублирования кода на основе мультипрофиля.

Для проверки анализа был использован набор тестов GeekBench. Были записаны трассы его исполнения на различных задачах. На тепловой карте (рисунок \cref{fig:HeatmapGKB}) выделены запуски различных задач, представляющие в данном случае сценарии запуска приложения. По верхней строке тепловой карты видно корректное выделение фаз на каждую отдельный тест из набора.

\begin{figure}[!h]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{_16}
    }
    \caption{Тепловая карта набора тестов Geekbench с выделенными тестами}\label{fig:HeatmapGKB}
\end{figure}

При использовании оптимизации дублирования кода на основе мультипрофильной информации удалось получить прирост производительности до 4\% на отдельных тестах из набора, но средний прирост на всех тестах не превышает 1\% (рисунок \cref{fig:ResGKB}). Это связано с отсутствием больших пересечений в коде набора тестов. Максимальный прирост был получен на мультипрофиле с 12 фазами, что коррелирует с порядком количества тестов в наборе.

\begin{figure}[!h]
    \centerfloat{
        \includegraphics[width=1.0\linewidth]{scores}
    }
    \caption{Результаты тестирования мультипрофильного дублирования кода на наборе тестов GeekBench}\label{fig:ResGKB}
\end{figure}

\FloatBarrier
\pdfbookmark{Заключение}{conclusion}                                  % Закладка pdf
В \underline{\textbf{заключении}} приведены основные результаты работы:
\input{common/concl}

\hfill \break

Разработанные в рамках диссертационного исследования алгоритмы и методы внедрены и используются:

\begin{enumerate}
  \item В бинарном оптимизаторе BOLT и его инфраструктуре, применяемых в ООО <<Техкомпания Хуавэй>> для оптимизации приложений.
  \item При чтении кафедрального курса «Современные методы разработки компиляторов» кафедры микропроцессорных технологий в интеллектуальных системах управления МФТИ.
\end{enumerate}

\newpage

\pdfbookmark{Литература}{bibliography}                                

\ifdefmacro{\microtypesetup}{\microtypesetup{protrusion=false}}{} % не рекомендуется применять пакет микротипографики к автоматически генерируемому списку литературы
\urlstyle{rm}                               % ссылки URL обычным шрифтом
\ifnumequal{\value{bibliosel}}{0}{% Встроенная реализация с загрузкой файла через движок bibtex8
    \renewcommand{\bibname}{\large \bibtitleauthor}
    \nocite{*}
    \insertbiblioauthor           % Подключаем Bib-базы
    %\insertbiblioexternal   % !!! bibtex не умеет работать с несколькими библиографиями !!!
}{% Реализация пакетом biblatex через движок biber
    % Цитирования.
    %  * Порядок перечисления определяет порядок в библиографии (только внутри подраздела, если `\insertbiblioauthorgrouped`).
    %  * Если не соблюдать порядок "как для \printbibliography", нумерация в `\insertbiblioauthor` будет кривой.
    %  * Если цитировать каждый источник отдельной командой --- найти некоторые ошибки будет проще.
    %
    %% authorvak
    \nocite{vakbib1}%
    \nocite{vakbib2}%
    %
    %% authorwos
    \nocite{wosbib1}%
    %
    %% authorscopus
    \nocite{scbib1}%
    %
    %% authorpathent
    \nocite{patbib1}%
    %
    %% authorprogram
    \nocite{progbib1}%
    %
    %% authorconf
    \nocite{confbib1}%
    \nocite{confbib2}%
    %
    %% authorother
    \nocite{bib1}%
    \nocite{bib2}%

    \ifnumgreater{\value{usefootcite}}{0}{
        \begin{refcontext}[labelprefix={}]
            \ifnum \value{bibgrouped}>0
                \insertbiblioauthorgrouped    % Вывод всех работ автора, сгруппированных по источникам
            \else
                \insertbiblioauthor      % Вывод всех работ автора
            \fi
        \end{refcontext}
    }{
        \ifnum \totvalue{citeexternal}>0
            \begin{refcontext}[labelprefix=A]
                \ifnum \value{bibgrouped}>0
                    \insertbiblioauthorgrouped    % Вывод всех работ автора, сгруппированных по источникам
                \else
                    \insertbiblioauthor      % Вывод всех работ автора
                \fi
            \end{refcontext}
        \else
            \ifnum \value{bibgrouped}>0
                \insertbiblioauthorgrouped    % Вывод всех работ автора, сгруппированных по источникам
            \else
                \insertbiblioauthor      % Вывод всех работ автора
            \fi
        \fi
        %  \insertbiblioauthorimportant  % Вывод наиболее значимых работ автора (определяется в файле characteristic во второй section)
        \begin{refcontext}[labelprefix={}]
            \insertbiblioexternal            % Вывод списка литературы, на которую ссылались в тексте автореферата
        \end{refcontext}
        % Невидимый библиографический список для подсчёта количества внешних публикаций
        % Используется, чтобы убрать приставку "А" у работ автора, если в автореферате нет
        % цитирований внешних источников.
        \printbibliography[heading=nobibheading, section=0, env=countexternal, keyword=biblioexternal, resetnumbers=true]%
    }
}
\ifdefmacro{\microtypesetup}{\microtypesetup{protrusion=true}}{}
\urlstyle{tt}                               % возвращаем установки шрифта ссылок URL
